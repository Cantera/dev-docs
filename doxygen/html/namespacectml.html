<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Cantera: ctml Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cantera
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ctml Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The ctml namespace adds functionality to the XML object, by providing standard functions that read, write, and interpret XML files and object trees.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace40c76ae8dd6a1d65934981b2c31572"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#ace40c76ae8dd6a1d65934981b2c31572">pypath</a> ()</td></tr>
<tr class="memdesc:ace40c76ae8dd6a1d65934981b2c31572"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the full path to the Python interpreter.  <a href="#ace40c76ae8dd6a1d65934981b2c31572"></a><br/></td></tr>
<tr class="separator:ace40c76ae8dd6a1d65934981b2c31572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106f302af6a947a6222a3450a5b888ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__inputfiles.html#ga106f302af6a947a6222a3450a5b888ab">ct2ctml</a> (const char *file, const int debug=0)</td></tr>
<tr class="memdesc:ga106f302af6a947a6222a3450a5b888ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cti file into a ctml file.  <a href="group__inputfiles.html#ga106f302af6a947a6222a3450a5b888ab"></a><br/></td></tr>
<tr class="separator:ga106f302af6a947a6222a3450a5b888ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea9a1b95781324c5037061411f9f5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a6ea9a1b95781324c5037061411f9f5c3">ck2cti</a> (const std::string &amp;in_file, const std::string &amp;thermo_file=&quot;&quot;, const std::string &amp;transport_file=&quot;&quot;, const std::string &amp;id_tag=&quot;gas&quot;)</td></tr>
<tr class="memdesc:a6ea9a1b95781324c5037061411f9f5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Chemkin-format mechanism into a CTI file.  <a href="#a6ea9a1b95781324c5037061411f9f5c3"></a><br/></td></tr>
<tr class="separator:a6ea9a1b95781324c5037061411f9f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ebdcc6cf8ff3cdc2dfcbd063b2260d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#aa1ebdcc6cf8ff3cdc2dfcbd063b2260d">get_CTML_Tree</a> (<a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> *node, const std::string &amp;file, const int debug=0)</td></tr>
<tr class="memdesc:aa1ebdcc6cf8ff3cdc2dfcbd063b2260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an ctml file from a file and fill up an XML tree.  <a href="#aa1ebdcc6cf8ff3cdc2dfcbd063b2260d"></a><br/></td></tr>
<tr class="separator:aa1ebdcc6cf8ff3cdc2dfcbd063b2260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746da172c61eeca2f165b4ea271d3c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a746da172c61eeca2f165b4ea271d3c46">getCtmlTree</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a746da172c61eeca2f165b4ea271d3c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an ctml file from a file and fill up an XML tree.  <a href="#a746da172c61eeca2f165b4ea271d3c46"></a><br/></td></tr>
<tr class="separator:a746da172c61eeca2f165b4ea271d3c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167cd9789b5570d51227d507a99ea697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a167cd9789b5570d51227d507a99ea697">addInteger</a> (<a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::string &amp;titleString, const int value, const std::string &amp;unitsString=&quot;&quot;, const std::string &amp;typeString=&quot;&quot;)</td></tr>
<tr class="memdesc:a167cd9789b5570d51227d507a99ea697"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a child node with the name, "integer", with a value consisting of a single integer.  <a href="#a167cd9789b5570d51227d507a99ea697"></a><br/></td></tr>
<tr class="separator:a167cd9789b5570d51227d507a99ea697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c742d62487489b333dfd2cad1e0ae70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a8c742d62487489b333dfd2cad1e0ae70">addFloat</a> (<a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::string &amp;titleString, const doublereal value, const std::string &amp;unitsString=&quot;&quot;, const std::string &amp;typeString=&quot;&quot;, const doublereal minval=<a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a>, const doublereal maxval=<a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a>)</td></tr>
<tr class="memdesc:a8c742d62487489b333dfd2cad1e0ae70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a child node with the name, "float", with a value consisting of a single floating point number.  <a href="#a8c742d62487489b333dfd2cad1e0ae70"></a><br/></td></tr>
<tr class="separator:a8c742d62487489b333dfd2cad1e0ae70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c49b0af6b746098bec5d1081c2f5a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a74c49b0af6b746098bec5d1081c2f5a1">addFloatArray</a> (<a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::string &amp;titleString, const size_t n, const doublereal *const values, const std::string &amp;unitsString=&quot;&quot;, const std::string &amp;typeString=&quot;&quot;, const doublereal minval=<a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a>, const doublereal maxval=<a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a>)</td></tr>
<tr class="memdesc:a74c49b0af6b746098bec5d1081c2f5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a child node with the name, "floatArray", with a value consisting of a comma separated list of floats.  <a href="#a74c49b0af6b746098bec5d1081c2f5a1"></a><br/></td></tr>
<tr class="separator:a74c49b0af6b746098bec5d1081c2f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f96b6e2a0c2ebb895846803d8ae563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#af9f96b6e2a0c2ebb895846803d8ae563">addString</a> (<a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::string &amp;titleString, const std::string &amp;valueString, const std::string &amp;typeString=&quot;&quot;)</td></tr>
<tr class="memdesc:af9f96b6e2a0c2ebb895846803d8ae563"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a child node with the name string with a string value to the current node.  <a href="#af9f96b6e2a0c2ebb895846803d8ae563"></a><br/></td></tr>
<tr class="separator:af9f96b6e2a0c2ebb895846803d8ae563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58ef9aba7fedd987dd4d5b92a85e35d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCantera_1_1XML__Node.html">XML_Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#aa58ef9aba7fedd987dd4d5b92a85e35d">getByTitle</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::string &amp;title)</td></tr>
<tr class="memdesc:aa58ef9aba7fedd987dd4d5b92a85e35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the child nodes of the current node for an XML Node with a Title attribute of a given name.  <a href="#aa58ef9aba7fedd987dd4d5b92a85e35d"></a><br/></td></tr>
<tr class="separator:aa58ef9aba7fedd987dd4d5b92a85e35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da2d5e6c61273b3216ab77449e18a29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a1da2d5e6c61273b3216ab77449e18a29">getChildValue</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;parent, const std::string &amp;nameString)</td></tr>
<tr class="memdesc:a1da2d5e6c61273b3216ab77449e18a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a child node with the name, nameString, and returns its xml value as the return string.  <a href="#a1da2d5e6c61273b3216ab77449e18a29"></a><br/></td></tr>
<tr class="separator:a1da2d5e6c61273b3216ab77449e18a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004e2c8753c727571bdbe263e6dd07ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a004e2c8753c727571bdbe263e6dd07ef">getNamedStringValue</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::string &amp;nameString, std::string &amp;valueString, std::string &amp;typeString)</td></tr>
<tr class="memdesc:a004e2c8753c727571bdbe263e6dd07ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts to read a named child node and returns with the contents in the value string.  <a href="#a004e2c8753c727571bdbe263e6dd07ef"></a><br/></td></tr>
<tr class="separator:a004e2c8753c727571bdbe263e6dd07ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e6a5de01d73bd5792ccb28fd4daa90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a33e6a5de01d73bd5792ccb28fd4daa90">getIntegers</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, std::map&lt; std::string, int &gt; &amp;v)</td></tr>
<tr class="memdesc:a33e6a5de01d73bd5792ccb28fd4daa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of integer values from a child element.  <a href="#a33e6a5de01d73bd5792ccb28fd4daa90"></a><br/></td></tr>
<tr class="separator:a33e6a5de01d73bd5792ccb28fd4daa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9066748f90f230d031b8b471b22ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a6d9066748f90f230d031b8b471b22ed3">getFloats</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, std::map&lt; std::string, double &gt; &amp;v, const bool convert=true)</td></tr>
<tr class="memdesc:a6d9066748f90f230d031b8b471b22ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of floating-point values from a child element.  <a href="#a6d9066748f90f230d031b8b471b22ed3"></a><br/></td></tr>
<tr class="separator:a6d9066748f90f230d031b8b471b22ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6877a213d219ec8760af38110ccd0bd4"><td class="memItemLeft" align="right" valign="top">doublereal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a6877a213d219ec8760af38110ccd0bd4">getFloat</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;parent, const std::string &amp;name, const std::string &amp;type=&quot;&quot;)</td></tr>
<tr class="memdesc:a6877a213d219ec8760af38110ccd0bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a floating-point value from a child element.  <a href="#a6877a213d219ec8760af38110ccd0bd4"></a><br/></td></tr>
<tr class="separator:a6877a213d219ec8760af38110ccd0bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4a01b1220c470e5f77c345099c3d9c"><td class="memItemLeft" align="right" valign="top">doublereal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a6f4a01b1220c470e5f77c345099c3d9c">getFloatCurrent</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;currXML, const std::string &amp;type=&quot;&quot;)</td></tr>
<tr class="memdesc:a6f4a01b1220c470e5f77c345099c3d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a floating-point value from the current XML element.  <a href="#a6f4a01b1220c470e5f77c345099c3d9c"></a><br/></td></tr>
<tr class="separator:a6f4a01b1220c470e5f77c345099c3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6337c1a64519ee2cc604b3807a6f52c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a6337c1a64519ee2cc604b3807a6f52c5">getOptionalFloat</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;parent, const std::string &amp;name, doublereal &amp;fltRtn, const std::string &amp;type=&quot;&quot;)</td></tr>
<tr class="memdesc:a6337c1a64519ee2cc604b3807a6f52c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an optional floating-point value from a child element.  <a href="#a6337c1a64519ee2cc604b3807a6f52c5"></a><br/></td></tr>
<tr class="separator:a6337c1a64519ee2cc604b3807a6f52c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91598da1f0fae5094ed10ac30623e02a"><td class="memItemLeft" align="right" valign="top">doublereal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a91598da1f0fae5094ed10ac30623e02a">getFloatDefaultUnits</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;parent, const std::string &amp;name, const std::string &amp;defaultUnits, const std::string &amp;type=&quot;toSI&quot;)</td></tr>
<tr class="memdesc:a91598da1f0fae5094ed10ac30623e02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a floating-point value from a child element with a defined units field.  <a href="#a91598da1f0fae5094ed10ac30623e02a"></a><br/></td></tr>
<tr class="separator:a91598da1f0fae5094ed10ac30623e02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cfb532fb9743b34600408a9df702c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a78cfb532fb9743b34600408a9df702c1">getOptionalModel</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;parent, const std::string &amp;nodeName, std::string &amp;modelName)</td></tr>
<tr class="memdesc:a78cfb532fb9743b34600408a9df702c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an optional model name from a named child node.  <a href="#a78cfb532fb9743b34600408a9df702c1"></a><br/></td></tr>
<tr class="separator:a78cfb532fb9743b34600408a9df702c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8fca5e53557ddf8916e916800474d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#abf8fca5e53557ddf8916e916800474d0">getInteger</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;parent, const std::string &amp;name)</td></tr>
<tr class="memdesc:abf8fca5e53557ddf8916e916800474d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an integer value from a child element.  <a href="#abf8fca5e53557ddf8916e916800474d0"></a><br/></td></tr>
<tr class="separator:abf8fca5e53557ddf8916e916800474d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd221ce115e20644501e262447700ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a2bd221ce115e20644501e262447700ef">getFloatArray</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, std::vector&lt; doublereal &gt; &amp;v, const bool convert=true, const std::string &amp;unitsString=&quot;&quot;, const std::string &amp;nodeName=&quot;floatArray&quot;)</td></tr>
<tr class="memdesc:a2bd221ce115e20644501e262447700ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the current node or a child node of the current node with the default name, "floatArray", with a value field consisting of a comma separated list of floats.  <a href="#a2bd221ce115e20644501e262447700ef"></a><br/></td></tr>
<tr class="separator:a2bd221ce115e20644501e262447700ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57d1cecac160f8c1a65be70f63ae771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#ae57d1cecac160f8c1a65be70f63ae771">getMap</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, std::map&lt; std::string, std::string &gt; &amp;m)</td></tr>
<tr class="memdesc:ae57d1cecac160f8c1a65be70f63ae771"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine is used to interpret the value portions of XML elements that contain colon separated pairs.  <a href="#ae57d1cecac160f8c1a65be70f63ae771"></a><br/></td></tr>
<tr class="separator:ae57d1cecac160f8c1a65be70f63ae771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5693e923feffee80495bc831981eeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#aac5693e923feffee80495bc831981eeb">getPairs</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, std::vector&lt; std::string &gt; &amp;key, std::vector&lt; std::string &gt; &amp;val)</td></tr>
<tr class="memdesc:aac5693e923feffee80495bc831981eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function interprets the value portion of an XML element as a series of "Pairs" separated by white space.  <a href="#aac5693e923feffee80495bc831981eeb"></a><br/></td></tr>
<tr class="separator:aac5693e923feffee80495bc831981eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e7fc6410349b1889738293ec0a776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a470e7fc6410349b1889738293ec0a776">getMatrixValues</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, const std::vector&lt; std::string &gt; &amp;keyStringRow, const std::vector&lt; std::string &gt; &amp;keyStringCol, <a class="el" href="classCantera_1_1Array2D.html">Cantera::Array2D</a> &amp;returnValues, const bool convert=true, const bool matrixSymmetric=false)</td></tr>
<tr class="memdesc:a470e7fc6410349b1889738293ec0a776"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function interprets the value portion of an XML element as a series of "Matrix ids and entries" separated by white space.  <a href="#a470e7fc6410349b1889738293ec0a776"></a><br/></td></tr>
<tr class="separator:a470e7fc6410349b1889738293ec0a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3895954f7c3fcce68146f9ddfff79164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#a3895954f7c3fcce68146f9ddfff79164">getStringArray</a> (const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;node, std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a3895954f7c3fcce68146f9ddfff79164"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function interprets the value portion of an XML element as a string.  <a href="#a3895954f7c3fcce68146f9ddfff79164"></a><br/></td></tr>
<tr class="separator:a3895954f7c3fcce68146f9ddfff79164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9fce5d232081ec7ccda1646c76e01c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9fce5d232081ec7ccda1646c76e01c6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>FP_Format</b> = &quot;%23.15E&quot;</td></tr>
<tr class="separator:ac9fce5d232081ec7ccda1646c76e01c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d22bb0f730681466a8a6ca6781a1cbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d22bb0f730681466a8a6ca6781a1cbb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>INT_Format</b> = &quot;%8d&quot;</td></tr>
<tr class="separator:a0d22bb0f730681466a8a6ca6781a1cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf11e90282d5d60b62491ed1413d2846"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacectml.html#adf11e90282d5d60b62491ed1413d2846">CTML_Version</a> = &quot;1.4.1&quot;</td></tr>
<tr class="memdesc:adf11e90282d5d60b62491ed1413d2846"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Specifying the CTML version number  <a href="#adf11e90282d5d60b62491ed1413d2846"></a><br/></td></tr>
<tr class="separator:adf11e90282d5d60b62491ed1413d2846"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The ctml namespace adds functionality to the XML object, by providing standard functions that read, write, and interpret XML files and object trees. </p>
<p>Standardization of reads and write from <a class="el" href="namespaceCantera.html" title="Provides class Nucleus.">Cantera</a> files occur here. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ace40c76ae8dd6a1d65934981b2c31572"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string ctml::pypath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the full path to the Python interpreter. </p>
<p>Use the environment variable PYTHON_CMD if it is set. If not, return the string 'python'.</p>
<p>Note, there are hidden problems here that really direct us to use a full pathname for the location of python. Basically the system call will use the shell /bin/sh, in order to launch python. This default shell may not be the shell that the user is employing. Therefore, the default path to python may be different during a system call than during the default user shell environment. This is quite a headache. The answer is to always set the PYTHON_CMD environmental variable in the user environment to an absolute path to locate the python executable. Then this issue goes away. </p>

<p>Definition at line <a class="el" href="ct2ctml_8cpp_source.html#l00043">43</a> of file <a class="el" href="ct2ctml_8cpp_source.html">ct2ctml.cpp</a>.</p>

<p>References <a class="el" href="stringUtils_8cpp_source.html#l00162">Cantera::stripws()</a>.</p>

<p>Referenced by <a class="el" href="ct2ctml_8cpp_source.html#l00138">ck2cti()</a>, and <a class="el" href="ct2ctml_8cpp_source.html#l00065">ct2ctml()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ea9a1b95781324c5037061411f9f5c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ck2cti </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thermo_file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>transport_file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id_tag</em> = <code>&quot;gas&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Chemkin-format mechanism into a CTI file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_file</td><td>input file containing species and reactions </td></tr>
    <tr><td class="paramname">thermo_file</td><td>optional input file containing thermo data </td></tr>
    <tr><td class="paramname">transport_file</td><td>optional input file containing transport parameters </td></tr>
    <tr><td class="paramname">id_tag</td><td>id of the phase </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ct2ctml_8cpp_source.html#l00138">138</a> of file <a class="el" href="ct2ctml_8cpp_source.html">ct2ctml.cpp</a>.</p>

<p>References <a class="el" href="ct2ctml_8cpp_source.html#l00043">pypath()</a>, <a class="el" href="stringUtils_8cpp_source.html#l00162">Cantera::stripws()</a>, and <a class="el" href="global_8cpp_source.html#l00034">Cantera::writelog()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1ebdcc6cf8ff3cdc2dfcbd063b2260d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_CTML_Tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>debug</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an ctml file from a file and fill up an XML tree. </p>
<p>This is the main routine that reads a ctml file and puts it into an XML_Node tree</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Root of the tree </td></tr>
    <tr><td class="paramname">file</td><td>Name of the file </td></tr>
    <tr><td class="paramname">debug</td><td>Turn on debugging printing </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ct2ctml_8cpp_source.html#l00232">232</a> of file <a class="el" href="ct2ctml_8cpp_source.html">ct2ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l01168">XML_Node::build()</a>, <a class="el" href="ct2ctml_8cpp_source.html#l00065">ct2ctml()</a>, <a class="el" href="global_8cpp_source.html#l00177">Cantera::findInputFile()</a>, <a class="el" href="stringUtils_8cpp_source.html#l00285">Cantera::getBaseName()</a>, <a class="el" href="ct__defs_8h_source.html#l00184">Cantera::npos</a>, <a class="el" href="global_8cpp_source.html#l00034">Cantera::writelog()</a>, and <a class="el" href="global_8cpp_source.html#l00044">Cantera::writelogf()</a>.</p>

<p>Referenced by <a class="el" href="ct2ctml_8cpp_source.html#l00283">getCtmlTree()</a>.</p>

</div>
</div>
<a class="anchor" id="a746da172c61eeca2f165b4ea271d3c46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> getCtmlTree </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an ctml file from a file and fill up an XML tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Name of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Root of the tree </dd></dl>

<p>Definition at line <a class="el" href="ct2ctml_8cpp_source.html#l00283">283</a> of file <a class="el" href="ct2ctml_8cpp_source.html">ct2ctml.cpp</a>.</p>

<p>References <a class="el" href="ct2ctml_8cpp_source.html#l00232">get_CTML_Tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a167cd9789b5570d51227d507a99ea697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>titleString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unitsString</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeString</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds a child node with the name, "integer", with a value consisting of a single integer. </p>
<pre class="fragment">This function will add a child node to the current XML node, with the
name "integer". It will have a title attribute, and the body
of the XML node will be filled out with a single integer
</pre><p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;node;
  std::string titleString = "maxIterations";
  int  value = 1000;
  std::string typeString = "optional";
  std::string units = "";
  addInteger(node, titleString, value, typeString, units);</pre><p>Creates the following the snippet in the XML file: </p>
<pre class="fragment">  &lt;parentNode&gt;
    &lt;integer title="maxIterations" type="optional"&gt;
       100
    &lt;\integer&gt;
  &lt;\parentNode&gt;
</pre> <pre class="fragment">@param node          reference to the XML_Node object of the parent XML element
@param titleString   String name of the title attribute
@param value         Value - single integer
@param unitsString   String name of the Units attribute. The default is to
                     have an empty string.
@param typeString    String type. This is an optional parameter. The default
                     is to have an empty string.
</pre><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>I don't think this is used. Figure out what is used for writing integers, and codify that. unitsString shouldn't be here, since it's an int. typeString should be codified as to its usage. </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00068">68</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00706">XML_Node::addAttribute()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c742d62487489b333dfd2cad1e0ae70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>titleString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const doublereal&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unitsString</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeString</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const doublereal&#160;</td>
          <td class="paramname"><em>minval</em> = <code><a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const doublereal&#160;</td>
          <td class="paramname"><em>maxval</em> = <code><a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds a child node with the name, "float", with a value consisting of a single floating point number. </p>
<pre class="fragment">This function will add a child node to the current XML node, with the
name "float". It will have a title attribute, and the body
of the XML node will be filled out with a single float
</pre><p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;node;
  std::string titleString = "activationEnergy";
  doublereal  value = 50.3;
  doublereal maxval = 1.0E3;
  doublereal minval = 0.0;
  std::string typeString = "optional";
  std::string unitsString = "kcal/gmol";
  addFloat(node, titleString, value, unitsString, typeString, minval, maxval);</pre><p>Creates the following the snippet in the XML file: </p>
<pre class="fragment">  &lt;parentNode&gt;
    &lt;float title="activationEnergy" type="optional" units="kcal/gmol" min="0.0" max="1.0E3"&gt;
       50.3
    &lt;\float&gt;
  &lt;\parentNode&gt;
</pre> <pre class="fragment">@param node          reference to the XML_Node object of the parent XML element
@param titleString   String name of the title attribute
@param value         Value - single integer
@param unitsString   String name of the Units attribute. The default is to
                     have an empty string.
@param typeString    String type. This is an optional parameter. The default
                     is to have an empty string.
@param minval        Minimum allowed value of the float. The default is the
                     special double, Cantera::Undef, which means to ignore the
                     entry.
@param maxval        Maximum allowed value of the float. The default is the
                     special double, Cantera::Undef, which means to ignore the
                     entry.
</pre><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>I don't think this is used. Figure out what is used for writing floats, and codify that. minval and maxval should be codified. typeString should be codified as to its usage. </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00128">128</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00706">XML_Node::addAttribute()</a>, and <a class="el" href="ct__defs_8h_source.html#l00158">Cantera::Undef</a>.</p>

<p>Referenced by <a class="el" href="boundaries1D_8cpp_source.html#l00242">Inlet1D::save()</a>, <a class="el" href="StFlow_8cpp_source.html#l01208">StFlow::save()</a>, <a class="el" href="boundaries1D_8cpp_source.html#l00679">OutletRes1D::save()</a>, <a class="el" href="boundaries1D_8cpp_source.html#l00781">Surf1D::save()</a>, and <a class="el" href="boundaries1D_8cpp_source.html#l00942">ReactingSurf1D::save()</a>.</p>

</div>
</div>
<a class="anchor" id="a74c49b0af6b746098bec5d1081c2f5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addFloatArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>titleString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const doublereal *const&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unitsString</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeString</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const doublereal&#160;</td>
          <td class="paramname"><em>minval</em> = <code><a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const doublereal&#160;</td>
          <td class="paramname"><em>maxval</em> = <code><a class="el" href="namespaceCantera.html#a87554f2f78829cfab3e24fd5b9d639f4">Cantera::Undef</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds a child node with the name, "floatArray", with a value consisting of a comma separated list of floats. </p>
<pre class="fragment">This function will add a child node to the current XML node, with the
name "floatArray". It will have a title attribute, and the body
of the XML node will be filled out with a comma separated list of
doublereals.
</pre><p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;node;
  std::string titleString = "additionalTemperatures";
  int  n = 3;
  int Tcases[3] = [273.15, 298.15, 373.15];
  std::string typeString = "optional";
  std::string units = "Kelvin";
  addFloatArray(node, titleString, n, &amp;cases[0], typeString, units);</pre><p>Creates the following the snippet in the XML file: </p>
<pre class="fragment">  &lt;parentNode&gt;
    &lt;floatArray title="additionalTemperatures" type="optional" units="Kelvin"&gt;
       273.15, 298.15, 373.15
    &lt;\floatArray&gt;
  &lt;\parentNode&gt;
</pre> <pre class="fragment">@param node          reference to the XML_Node object of the parent XML element
@param titleString   String name of the title attribute
@param n             Length of the doubles vector.
@param values        Pointer to a vector of doubles
@param unitsString   String name of the Units attribute. This is an optional
                     parameter. The default is to
                     have an empty string.
@param typeString    String type. This is an optional parameter. The default
                     is to have an empty string.
@param minval        Minimum allowed value of the int. This is an optional
                     parameter. The default is the
                     special double, Cantera::Undef, which means to ignore the
                     entry.
@param maxval        Maximum allowed value of the int. This is an optional
                     parameter. The default is the
                     special double, Cantera::Undef, which means to ignore the
                     entry.
</pre><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>I don't think this is used. Figure out what is used for writing integers, and codify that. unitsString shouldn't be here, since it's an int. typeString should be codified as to its usage. </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00204">204</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00706">XML_Node::addAttribute()</a>, <a class="el" href="stringUtils_8cpp_source.html#l00042">Cantera::fp2str()</a>, and <a class="el" href="ct__defs_8h_source.html#l00158">Cantera::Undef</a>.</p>

<p>Referenced by <a class="el" href="StFlow_8cpp_source.html#l01208">StFlow::save()</a>.</p>

</div>
</div>
<a class="anchor" id="af9f96b6e2a0c2ebb895846803d8ae563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>titleString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>valueString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeString</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds a child node with the name string with a string value to the current node. </p>
<pre class="fragment">This function will add a child node to the current XML node, with the
name "string". It will have a title attribute, and the body
of the XML node will be filled out with the valueString argument verbatim.
</pre><p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;node;
addString(XML_Node&amp; node, std::string titleString, std::string valueString,
std::string typeString);
</pre><p>Creates the following the snippet in the XML file: </p>
<pre class="fragment">&lt;string title="titleString" type="typeString"&gt;
  valueString
&lt;\string&gt;
</pre> <pre class="fragment">@param node          reference to the XML_Node object of the parent XML element
@param valueString   Value string to be used in the new XML node.
@param titleString   String name of the title attribute
@param typeString    String type. This is an optional parameter.</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00267">267</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00706">XML_Node::addAttribute()</a>.</p>

<p>Referenced by <a class="el" href="StFlow_8cpp_source.html#l01208">StFlow::save()</a>.</p>

</div>
</div>
<a class="anchor" id="aa58ef9aba7fedd987dd4d5b92a85e35d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> * getByTitle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the child nodes of the current node for an XML Node with a Title attribute of a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Current node from which to conduct the search </td></tr>
    <tr><td class="paramname">title</td><td>Name of the title attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the matched child node. Returns 0 if no node is found. </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00278">278</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l01074">XML_Node::findByAttr()</a>, and <a class="el" href="xml_8cpp_source.html#l00803">XML_Node::parent()</a>.</p>

<p>Referenced by <a class="el" href="ctml_8cpp_source.html#l00325">getNamedStringValue()</a>, <a class="el" href="TransportFactory_8cpp_source.html#l00910">TransportFactory::getTransportData()</a>, and <a class="el" href="Mu0Poly_8cpp_source.html#l00204">Cantera::installMu0ThermoFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a1da2d5e6c61273b3216ab77449e18a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getChildValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a child node with the name, nameString, and returns its xml value as the return string. </p>
<pre class="fragment">If the child XML_node named "name" doesn't exist, the empty string is returned.
</pre><p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;parent;
string nameString = "vacancy_species";
string valueString = getChildValue(parent, nameString
std::string typeString);
</pre><p>returns valueString = "O(V)"</p>
<p>from the following the snippet in the XML file:</p>
<pre class="fragment">&lt;vacancySpecies&gt;
  O(V)
&lt;\vacancySpecies&gt;
</pre> <pre class="fragment">@param parent     parent reference to the XML_Node object of the parent XML element
@param nameString Name of the child XML_Node to read the value from.

@return           String value of the child XML_Node</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00318">318</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00826">XML_Node::hasChild()</a>.</p>

<p>Referenced by <a class="el" href="DebyeHuckel_8cpp_source.html#l00957">DebyeHuckel::initThermoXML()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l01269">HMWSoln::initThermoXML()</a>, <a class="el" href="LatticePhase_8cpp_source.html#l00494">LatticePhase::setParametersFromXML()</a>, <a class="el" href="SurfPhase_8cpp_source.html#l00454">SurfPhase::setStateFromXML()</a>, <a class="el" href="MixtureFugacityTP_8cpp_source.html#l00443">MixtureFugacityTP::setStateFromXML()</a>, <a class="el" href="MolalityVPSSTP_8cpp_source.html#l00623">MolalityVPSSTP::setStateFromXML()</a>, and <a class="el" href="ThermoPhase_8cpp_source.html#l00924">ThermoPhase::setStateFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a004e2c8753c727571bdbe263e6dd07ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getNamedStringValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>valueString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>typeString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts to read a named child node and returns with the contents in the value string. </p>
<p>title attribute named "titleString"</p>
<pre class="fragment">This function will read a child node to the current XML node, with the
name "string". It must have a title attribute, named titleString, and the body
of the XML node will be read into the valueString output argument.

If the child node is not found then the empty string is returned.
</pre><p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;node;
  std::string valueString;
  std::string typeString;
  std::string nameString = "timeIncrement";
  getString(XML_Node&amp; node, nameString, valueString, valueString, typeString);
</pre><p>Reads the following the snippet in the XML file:</p>
<ul>
<li><pre class="fragment">&lt;nameString type="typeString"&gt;
  valueString
&lt;\nameString&gt;
</pre></li>
</ul>
<p>or alternatively as a retrofit and special case, it also reads the following case</p>
<pre class="fragment">&lt;string title="nameString" type="typeString"&gt;
  valueString
&lt;\string&gt;
</pre> <pre class="fragment">@param node          Reference to the XML_Node object of the parent XML element
@param nameString    Name of the XML Node                               input  variable
@param valueString   Value string that is found in the child node.      output variable
@param typeString    String type. This is an optional output variable. It is filled
                     with the attribute "type" of the XML entry.         output variable</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00325">325</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00846">XML_Node::child()</a>, <a class="el" href="ctml_8cpp_source.html#l00278">getByTitle()</a>, <a class="el" href="xml_8cpp_source.html#l00826">XML_Node::hasChild()</a>, <a class="el" href="xml_8h_source.html#l00444">XML_Node::name()</a>, and <a class="el" href="xml_8cpp_source.html#l00643">XML_Node::value()</a>.</p>

</div>
</div>
<a class="anchor" id="a33e6a5de01d73bd5792ccb28fd4daa90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getIntegers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector of integer values from a child element. </p>
<p>Returns a std::map containing a keyed values for child XML_Nodes of the current node with the name, "integer". In the keyed mapping there will be a list of titles vs. values for all of the XML nodes. The integer XML_nodes are expected to be in a particular form created by the function <a class="el" href="namespacectml.html#a167cd9789b5570d51227d507a99ea697" title="This function adds a child node with the name, &quot;integer&quot;, with a value consisting of a single integer...">addInteger()</a>. One value per XML_node is expected.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;State_XMLNode;
  std::map&lt;std::string, integer&gt; v;
  getinteger(State_XMLNode, v);
</pre><p>reads the corresponding XML file:</p>
<pre class="fragment">&lt;state&gt;
  &lt;integer title="i1"&gt;   1  &lt;\integer&gt;
  &lt;integer title="i2"&gt;   2  &lt;\integer&gt;
  &lt;integer title="i3"&gt;   3  &lt;\integer&gt;
&lt;\state&gt;
</pre><p>Will produce the mapping: </p>
<pre class="fragment">   v["i1"] = 1
   v["i2"] = 2
   v["i3"] = 3
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Current XML node to get the values from </td></tr>
    <tr><td class="paramname">v</td><td>Output map of the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00387">387</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l01337">XML_Node::getChildren()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d9066748f90f230d031b8b471b22ed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFloats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>convert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector of floating-point values from a child element. </p>
<p>Returns a std::map containing a keyed values for child XML_Nodes of the current node with the name, "float". In the keyed mapping there will be a list of titles vs. values for all of the XML nodes. The float XML_nodes are expected to be in a particular form created by the function <a class="el" href="namespacectml.html#a8c742d62487489b333dfd2cad1e0ae70" title="This function adds a child node with the name, &quot;float&quot;, with a value consisting of a single floating ...">addFloat()</a>. One value per XML_node is expected.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;State_XMLNode;
  std::map&lt;std::string,double&gt; v;
  bool convert = true;
  getFloats(State_XMLNode, v, convert);
</pre><p>reads the corresponding XML file:</p>
<pre class="fragment">&lt;state&gt;
  &lt;float title="a1" units="m3"&gt;   32.4 &lt;\float&gt;
  &lt;float title="a2" units="cm3"&gt;   1.  &lt;\float&gt;
  &lt;float title="a3"&gt;             100.  &lt;\float&gt;
&lt;\state&gt;
</pre><p>Will produce the mapping: </p>
<pre class="fragment">   v["a1"] = 32.4
   v["a2"] = 1.0E-6
   v["a3"] = 100.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Current XML node to get the values from </td></tr>
    <tr><td class="paramname">v</td><td>Output map of the results. </td></tr>
    <tr><td class="paramname">convert</td><td>Turn on conversion to SI units </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00450">450</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l01337">XML_Node::getChildren()</a>, <a class="el" href="ct__defs_8h_source.html#l00166">Cantera::Tiny</a>, <a class="el" href="global_8cpp_source.html#l00182">Cantera::toSI()</a>, <a class="el" href="ct__defs_8h_source.html#l00158">Cantera::Undef</a>, and <a class="el" href="global_8cpp_source.html#l00034">Cantera::writelog()</a>.</p>

</div>
</div>
<a class="anchor" id="a6877a213d219ec8760af38110ccd0bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">doublereal getFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a floating-point value from a child element. </p>
<p>Returns a doublereal value for the child named 'name' of element 'parent'. If 'type' is supplied and matches a known unit type, unit conversion to SI will be done if the child element has an attribute 'units'.</p>
<p>Note, it's an error for the child element not to exist.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;State_XMLNode;
doublereal pres = OneAtm;
if (state_XMLNode.hasChild("pressure")) {
  pres = getFloat(State_XMLNode, "pressure", "toSI");
}
</pre><p>reads the corresponding XML file: </p>
<pre class="fragment">&lt;state&gt;
  &lt;pressure units="Pa"&gt; 101325.0 &lt;/pressure&gt;
&lt;\state&gt;
</pre> <pre class="fragment">@param parent reference to the XML_Node object of the parent XML element
@param name   Name of the XML child element
@param type   String type. Currently known types are "toSI" and "actEnergy",
              and "" , for no conversion. The default value is "",
              which implies that no conversion is allowed.</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00521">521</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00846">XML_Node::child()</a>, <a class="el" href="ctml_8cpp_source.html#l00566">getFloatCurrent()</a>, <a class="el" href="xml_8cpp_source.html#l00826">XML_Node::hasChild()</a>, and <a class="el" href="xml_8h_source.html#l00444">XML_Node::name()</a>.</p>

<p>Referenced by <a class="el" href="PDSS__ConstVol_8cpp_source.html#l00104">PDSS_ConstVol::constructPDSSXML()</a>, <a class="el" href="PDSS__HKFT_8cpp_source.html#l00651">PDSS_HKFT::constructPDSSXML()</a>, <a class="el" href="PDSS__SSVol_8cpp_source.html#l00118">PDSS_SSVol::constructPDSSXML()</a>, <a class="el" href="VPSSMgr__ConstVol_8cpp_source.html#l00162">VPSSMgr_ConstVol::createInstallPDSS()</a>, <a class="el" href="VPSSMgr__Water__ConstVol_8cpp_source.html#l00260">VPSSMgr_Water_ConstVol::createInstallPDSS()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00286">Cantera::getArrhenius()</a>, <a class="el" href="ctml_8cpp_source.html#l00671">getFloatDefaultUnits()</a>, <a class="el" href="ctml_8cpp_source.html#l00623">getOptionalFloat()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00506">Cantera::getRateCoefficient()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00321">Cantera::getStick()</a>, <a class="el" href="TransportFactory_8cpp_source.html#l00910">TransportFactory::getTransportData()</a>, <a class="el" href="LiquidTranInteraction_8cpp_source.html#l00086">LiquidTranInteraction::init()</a>, <a class="el" href="VPSSMgr__ConstVol_8cpp_source.html#l00127">VPSSMgr_ConstVol::initThermoXML()</a>, <a class="el" href="VPSSMgr__Water__ConstVol_8cpp_source.html#l00218">VPSSMgr_Water_ConstVol::initThermoXML()</a>, <a class="el" href="MineralEQ3_8cpp_source.html#l00481">MineralEQ3::initThermoXML()</a>, <a class="el" href="IdealMolalSoln_8cpp_source.html#l00845">IdealMolalSoln::initThermoXML()</a>, <a class="el" href="LatticePhase_8cpp_source.html#l00410">LatticePhase::initThermoXML()</a>, <a class="el" href="IdealSolidSolnPhase_8cpp_source.html#l01090">IdealSolidSolnPhase::initThermoXML()</a>, <a class="el" href="DebyeHuckel_8cpp_source.html#l00957">DebyeHuckel::initThermoXML()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l01269">HMWSoln::initThermoXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00703">Cantera::installAdsorbateThermoFromXML()</a>, <a class="el" href="Mu0Poly_8cpp_source.html#l00204">Cantera::installMu0ThermoFromXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00568">Cantera::installSimpleThermoFromXML()</a>, <a class="el" href="ThermoFactory_8cpp_source.html#l00706">Cantera::installSpecies()</a>, <a class="el" href="LTPspecies_8cpp_source.html#l00066">LTPspecies::LTPspecies()</a>, <a class="el" href="SemiconductorPhase_8h_source.html#l00069">SemiconductorPhase::setParametersFromXML()</a>, <a class="el" href="SurfPhase_8cpp_source.html#l00512">EdgePhase::setParametersFromXML()</a>, <a class="el" href="MetalPhase_8h_source.html#l00120">MetalPhase::setParametersFromXML()</a>, <a class="el" href="ConstDensityThermo_8cpp_source.html#l00178">ConstDensityThermo::setParametersFromXML()</a>, <a class="el" href="SurfPhase_8cpp_source.html#l00442">SurfPhase::setParametersFromXML()</a>, <a class="el" href="StoichSubstance_8cpp_source.html#l00292">StoichSubstance::setParametersFromXML()</a>, <a class="el" href="StoichSubstanceSSTP_8cpp_source.html#l00494">StoichSubstanceSSTP::setParametersFromXML()</a>, <a class="el" href="MetalSHEelectrons_8cpp_source.html#l00548">MetalSHEelectrons::setParametersFromXML()</a>, <a class="el" href="LatticePhase_8cpp_source.html#l00494">LatticePhase::setParametersFromXML()</a>, <a class="el" href="MixtureFugacityTP_8cpp_source.html#l00443">MixtureFugacityTP::setStateFromXML()</a>, <a class="el" href="MolalityVPSSTP_8cpp_source.html#l00623">MolalityVPSSTP::setStateFromXML()</a>, and <a class="el" href="ThermoPhase_8cpp_source.html#l00924">ThermoPhase::setStateFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f4a01b1220c470e5f77c345099c3d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">doublereal getFloatCurrent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>currXML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a floating-point value from the current XML element. </p>
<p>Returns a doublereal value from the current element. If 'type' is supplied and matches a known unit type, unit conversion to SI will be done if the child element has an attribute 'units'.</p>
<p>Note, it's an error for the child element not to exist.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;State_XMLNode;
doublereal pres = OneAtm;
if (state_XMLNode.hasChild("pressure")) {
  XML_Node *pres_XMLNode = State_XMLNode.getChild("pressure");
  pres = getFloatCurrent(pres_XMLNode, "toSI");
}
</pre><p>Reads the corresponding XML file: </p>
<pre class="fragment">&lt;state&gt;
  &lt;pressure units="Pa"&gt; 101325.0 &lt;/pressure&gt;
&lt;\state&gt;
</pre> <pre class="fragment">@param currXML reference to the current XML_Node object
@param type   String type. Currently known types are "toSI" and "actEnergy",
              and "" , for no conversion. The default value is "",
              which implies that no conversion is allowed.</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00566">566</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="global_8cpp_source.html#l00193">Cantera::actEnergyToSI()</a>, <a class="el" href="xml_8h_source.html#l00444">XML_Node::name()</a>, <a class="el" href="ct__defs_8h_source.html#l00166">Cantera::Tiny</a>, <a class="el" href="global_8cpp_source.html#l00182">Cantera::toSI()</a>, <a class="el" href="ct__defs_8h_source.html#l00158">Cantera::Undef</a>, and <a class="el" href="global_8cpp_source.html#l00034">Cantera::writelog()</a>.</p>

<p>Referenced by <a class="el" href="ctml_8cpp_source.html#l00521">getFloat()</a>, and <a class="el" href="LTPspecies_8cpp_source.html#l00156">LTPspecies_Const::LTPspecies_Const()</a>.</p>

</div>
</div>
<a class="anchor" id="a6337c1a64519ee2cc604b3807a6f52c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getOptionalFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">doublereal &amp;&#160;</td>
          <td class="paramname"><em>fltRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an optional floating-point value from a child element. </p>
<p>Returns a doublereal value for the child named 'name' of element 'parent'. If 'type' is supplied and matches a known unit type, unit conversion to SI will be done if the child element has an attribute 'units'.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;State_XMLNode;
doublereal pres = OneAtm;
bool exists = getOptionalFloat(State_XMLNode, "pressure", pres, "toSI");
</pre><p>reads the corresponding XML file: </p>
<pre class="fragment">&lt;state&gt;
  &lt;pressure units="Pa"&gt; 101325.0 &lt;/pressure&gt;
&lt;\state&gt;
</pre> <pre class="fragment">@param parent reference to the XML_Node object of the parent XML element
@param name   Name of the XML child element
@param fltRtn Float Return. It will be overridden if the XML
              element exists.
@param type   String type. Currently known types are "toSI"
              and "actEnergy",
              and "" , for no conversion. The default value is "",
              which implies that no conversion is allowed.
</pre><dl class="section return"><dt>Returns</dt><dd>returns true if the child element named "name" exists </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00623">623</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="ctml_8cpp_source.html#l00521">getFloat()</a>, and <a class="el" href="xml_8cpp_source.html#l00826">XML_Node::hasChild()</a>.</p>

<p>Referenced by <a class="el" href="HMWSoln__input_8cpp_source.html#l01269">HMWSoln::initThermoXML()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l01012">HMWSoln::readXMLCroppingCoefficients()</a>, and <a class="el" href="SurfPhase_8cpp_source.html#l00454">SurfPhase::setStateFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a91598da1f0fae5094ed10ac30623e02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">doublereal getFloatDefaultUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;toSI&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a floating-point value from a child element with a defined units field. </p>
<p>Returns a doublereal value for the child named 'name' of element 'parent'. 'type' must be supplied and match a known unit type.</p>
<p>Note, it's an error for the child element not to exist.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;State_XMLNode;
doublereal pres = OneAtm;
if (state_XMLNode.hasChild("pressure")) {
pres = getFloatDefaultUnits(State_XMLNode, "pressure", "Pa", "toSI");
}
</pre><p>reads the corresponding XML file: </p>
<pre class="fragment">&lt;state&gt;
  &lt;pressure units="Pa"&gt; 101325.0 &lt;/pressure&gt;
&lt;\state&gt;
</pre> <pre class="fragment">@param parent reference to the XML_Node object of the parent XML element
@param name   Name of the XML child element
@param defaultUnits Default units string to be found in the units attribute.
              If the units string in the XML field is equal to defaultUnits,
              no units conversion will be carried out.
@param type   String type. Currently known types are "toSI" and "actEnergy",
              and "" , for no conversion. The default value is "",
              which implies that no conversion is allowed.</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00671">671</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="global_8cpp_source.html#l00193">Cantera::actEnergyToSI()</a>, <a class="el" href="ctml_8cpp_source.html#l00521">getFloat()</a>, and <a class="el" href="global_8cpp_source.html#l00182">Cantera::toSI()</a>.</p>

<p>Referenced by <a class="el" href="StoichSubstanceSSTP_8cpp_source.html#l00440">StoichSubstanceSSTP::initThermoXML()</a>, <a class="el" href="MineralEQ3_8cpp_source.html#l00481">MineralEQ3::initThermoXML()</a>, <a class="el" href="MetalSHEelectrons_8cpp_source.html#l00438">MetalSHEelectrons::initThermoXML()</a>, <a class="el" href="FixedChemPotSSTP_8cpp_source.html#l00501">FixedChemPotSSTP::initThermoXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00415">Cantera::installMinEQ3asShomateThermoFromXML()</a>, and <a class="el" href="FixedChemPotSSTP_8cpp_source.html#l00550">FixedChemPotSSTP::setParametersFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a78cfb532fb9743b34600408a9df702c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getOptionalModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>modelName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an optional model name from a named child node. </p>
<p>Returns the model name attribute for the child named 'nodeName' of element 'parent'. Note, it's optional for the child node to exist</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">std::string modelName = "";
bool exists = getOptionalModel(transportNode, "compositionDependence",
                 modelName);
</pre><p>reads the corresponding XML file: </p>
<pre class="fragment"> &lt;transport model="Simple"&gt;
   &lt;compositionDependence model="Solvent_Only"/&gt;
 &lt;/transport&gt;
</pre> <pre class="fragment">On return modelName is set to "Solvent_Only".

@param parent reference to the XML_Node object of the parent XML element
@param nodeName   Name of the XML child element
@param modelName  On return this contains the contents of the model attribute

@return True if the nodeName XML node exists. False otherwise.</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00731">731</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00846">XML_Node::child()</a>, and <a class="el" href="xml_8cpp_source.html#l00826">XML_Node::hasChild()</a>.</p>

<p>Referenced by <a class="el" href="SimpleTransport_8cpp_source.html#l00178">SimpleTransport::initLiquid()</a>.</p>

</div>
</div>
<a class="anchor" id="abf8fca5e53557ddf8916e916800474d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an integer value from a child element. </p>
<p>Returns an integer value for the child named 'name' of element 'parent'.</p>
<p>Note, it's an error for the child element not to exist.</p>
<p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">const XML_Node &amp;State_XMLNode;
int number = 1;
if (state_XMLNode.hasChild("NumProcs")) {
number = getInteger(State_XMLNode, "numProcs");
}
</pre><p>reads the corresponding XML file: </p>
<pre class="fragment">&lt;state&gt;
  &lt;numProcs&gt; 10 &lt;numProcs/&gt;
&lt;\state&gt;
</pre> <pre class="fragment">@param parent reference to the XML_Node object of the parent XML element
@param name   Name of the XML child element</pre> 
<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00769">769</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="xml_8cpp_source.html#l00846">XML_Node::child()</a>, <a class="el" href="xml_8cpp_source.html#l00826">XML_Node::hasChild()</a>, <a class="el" href="xml_8h_source.html#l00444">XML_Node::name()</a>, and <a class="el" href="global_8cpp_source.html#l00034">Cantera::writelog()</a>.</p>

<p>Referenced by <a class="el" href="Mu0Poly_8cpp_source.html#l00204">Cantera::installMu0ThermoFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bd221ce115e20644501e262447700ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getFloatArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; doublereal &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>convert</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unitsString</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em> = <code>&quot;floatArray&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the current node or a child node of the current node with the default name, "floatArray", with a value field consisting of a comma separated list of floats. </p>
<pre class="fragment">This function will read either the current XML node or a  child node
to the current XML node, with the
name "floatArray". It will have a title attribute, and the body
of the XML node will be filled out with a comma separated list of
doublereals.
  Get an array of floats from the XML Node. The argument field
is assumed to consist of an arbitrary number of comma
separated floats, with an arbitrary amount of white space
separating each field.
   If the node array has an units attribute field, then
the units are used to convert the floats, iff convert is true.
</pre><p>Example:</p>
<p>Code snippet: </p>
<pre class="fragment">  const XML_Node &amp;State_XMLNode;
  vector_fp v;
  bool convert = true;
  unitsString = "";
  nodeName="floatArray";
  getFloatArray(State_XMLNode, v, convert, unitsString, nodeName);
</pre><p>reads the corresponding XML file:</p>
<pre class="fragment">&lt;state&gt;
  &lt;floatArray  units="m3"&gt;   32.4, 1, 100. &lt;\floatArray&gt;
&lt;\state&gt;
</pre><p>Will produce the vector </p>
<pre class="fragment">   v[0] = 32.4
   v[1] = 1.0
   v[2] = 100.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>XML parent node of the floatArray </td></tr>
    <tr><td class="paramname">v</td><td>Output vector of floats containing the floatArray information. </td></tr>
    <tr><td class="paramname">convert</td><td>Conversion to SI is carried out if this boolean is True. The default is true. </td></tr>
    <tr><td class="paramname">unitsString</td><td>String name of the type attribute. This is an optional parameter. The default is to have an empty string. The only string that is recognized is actEnergy. Anything else has no effect. This affects what units converter is used. </td></tr>
    <tr><td class="paramname">nodeName</td><td>XML Name of the XML node to read. The default value for the node name is floatArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of floats read into v. </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00860">860</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="global_8cpp_source.html#l00193">Cantera::actEnergyToSI()</a>, <a class="el" href="stringUtils_8cpp_source.html#l00478">Cantera::atofCheck()</a>, <a class="el" href="stringUtils_8cpp_source.html#l00042">Cantera::fp2str()</a>, <a class="el" href="xml_8cpp_source.html#l01337">XML_Node::getChildren()</a>, <a class="el" href="xml_8h_source.html#l00444">XML_Node::name()</a>, <a class="el" href="ct__defs_8h_source.html#l00184">Cantera::npos</a>, <a class="el" href="ct__defs_8h_source.html#l00166">Cantera::Tiny</a>, <a class="el" href="global_8cpp_source.html#l00182">Cantera::toSI()</a>, <a class="el" href="ct__defs_8h_source.html#l00158">Cantera::Undef</a>, <a class="el" href="xml_8cpp_source.html#l00643">XML_Node::value()</a>, and <a class="el" href="global_8cpp_source.html#l00034">Cantera::writelog()</a>.</p>

<p>Referenced by <a class="el" href="PDSS__SSVol_8cpp_source.html#l00118">PDSS_SSVol::constructPDSSXML()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00506">Cantera::getRateCoefficient()</a>, <a class="el" href="LiquidTranInteraction_8cpp_source.html#l00086">LiquidTranInteraction::init()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00703">Cantera::installAdsorbateThermoFromXML()</a>, <a class="el" href="Mu0Poly_8cpp_source.html#l00204">Cantera::installMu0ThermoFromXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00598">Cantera::installNasa9ThermoFromXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00279">Cantera::installNasaThermoFromXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00502">Cantera::installShomateThermoFromXML()</a>, <a class="el" href="SpeciesThermoFactory_8cpp_source.html#l00652">Cantera::installStatMechThermoFromXML()</a>, <a class="el" href="LTPspecies_8cpp_source.html#l00408">LTPspecies_ExpT::LTPspecies_ExpT()</a>, <a class="el" href="LTPspecies_8cpp_source.html#l00335">LTPspecies_Poly::LTPspecies_Poly()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00070">HMWSoln::readXMLBinarySalt()</a>, <a class="el" href="PhaseCombo__Interaction_8cpp_source.html#l01048">PhaseCombo_Interaction::readXMLBinarySpecies()</a>, <a class="el" href="RedlichKisterVPSSTP_8cpp_source.html#l00877">RedlichKisterVPSSTP::readXMLBinarySpecies()</a>, <a class="el" href="MargulesVPSSTP_8cpp_source.html#l00985">MargulesVPSSTP::readXMLBinarySpecies()</a>, <a class="el" href="MixedSolventElectrolyte_8cpp_source.html#l00983">MixedSolventElectrolyte::readXMLBinarySpecies()</a>, <a class="el" href="RedlichKwongMFTP_8cpp_source.html#l01105">RedlichKwongMFTP::readXMLCrossFluid()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00746">HMWSoln::readXMLLambdaNeutral()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00832">HMWSoln::readXMLMunnnNeutral()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00596">HMWSoln::readXMLPsiCommonAnion()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00450">HMWSoln::readXMLPsiCommonCation()</a>, <a class="el" href="RedlichKwongMFTP_8cpp_source.html#l01023">RedlichKwongMFTP::readXMLPureFluid()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00276">HMWSoln::readXMLThetaAnion()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l00363">HMWSoln::readXMLThetaCation()</a>, and <a class="el" href="HMWSoln__input_8cpp_source.html#l00907">HMWSoln::readXMLZetaCation()</a>.</p>

</div>
</div>
<a class="anchor" id="ae57d1cecac160f8c1a65be70f63ae771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine is used to interpret the value portions of XML elements that contain colon separated pairs. </p>
<p>These are used, for example, in describing the element composition of species. </p>
<pre class="fragment">     &lt;atomArray&gt; H:4 C:1 &lt;atomArray\&gt;
</pre><p> The string is first separated into a string vector according to the location of white space. Then each string is again separated into two parts according to the location of a colon in the string. The first part of the string is used as the key, while the second part of the string is used as the value, in the return map. It is an error to not find a colon in each string pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Current node </td></tr>
    <tr><td class="paramname">m</td><td>Output Map containing the pairs of values found in the XML Node </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l00970">970</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="ctml_8cpp_source.html#l01180">getStringArray()</a>, and <a class="el" href="ct__defs_8h_source.html#l00184">Cantera::npos</a>.</p>

<p>Referenced by <a class="el" href="DebyeHuckel_8cpp_source.html#l00957">DebyeHuckel::initThermoXML()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l01269">HMWSoln::initThermoXML()</a>, and <a class="el" href="ThermoFactory_8cpp_source.html#l00706">Cantera::installSpecies()</a>.</p>

</div>
</div>
<a class="anchor" id="aac5693e923feffee80495bc831981eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getPairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function interprets the value portion of an XML element as a series of "Pairs" separated by white space. </p>
<p>Each pair consists of non-whitespace characters. The first ":" found in the pair string is used to separate the string into two parts. The first part is called the "key" The second part is called the "val". String vectors of key[i] and val[i] are returned in the argument list. Warning: No spaces are allowed in each pair. Quotes get included as part of the string. Example: </p>
<pre class="fragment">  &lt;xmlNode&gt;
     red:112    blue:34
     green:banana
  &lt;/xmlNode&gt;</pre><p>Returns: key val 0: "red" "112" 1: "blue" "34" 2: "green" "banana"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>XML Node </td></tr>
    <tr><td class="paramname">key</td><td>Vector of keys for each entry </td></tr>
    <tr><td class="paramname">val</td><td>Vector of values for each entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of pairs found </dd></dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l01020">1020</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="ctml_8cpp_source.html#l01180">getStringArray()</a>, and <a class="el" href="ct__defs_8h_source.html#l00184">Cantera::npos</a>.</p>

<p>Referenced by <a class="el" href="PDSS__IonsFromNeutral_8cpp_source.html#l00151">PDSS_IonsFromNeutral::constructPDSSXML()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00475">Cantera::getEfficiencies()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00177">Cantera::getReagents()</a>, and <a class="el" href="LatticeSolidPhase_8cpp_source.html#l00629">LatticeSolidPhase::setParametersFromXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a470e7fc6410349b1889738293ec0a776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMatrixValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyStringRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyStringCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCantera_1_1Array2D.html">Cantera::Array2D</a> &amp;&#160;</td>
          <td class="paramname"><em>returnValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>convert</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>matrixSymmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function interprets the value portion of an XML element as a series of "Matrix ids and entries" separated by white space. </p>
<p>Each pair consists of non-whitespace characters. The first two ":" found in the pair string is used to separate the string into three parts. The first part is called the first key. The second part is the second key. Both parts must match an entry in the keyString1 and keyString2, respectively, in order to provide a location to place the object in the matrix. The third part is called the value. It is expected to be a double. It is translated into a double and placed into the correct location in the matrix.</p>
<p>Warning: No spaces are allowed in each triplet. Quotes are part of the string. Example keyString = red, blue, black, green</p>
<pre class="fragment">    &lt;xmlNode&gt;
        red:green:112
        blue:black:3.3E-23

    &lt;/xmlNode&gt;
</pre><p> Returns: retnValues(0, 3) = 112 retnValues(1, 2) = 3.3E-23</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>XML Node containing the information for the matrix </td></tr>
    <tr><td class="paramname">keyStringRow</td><td>Key string for the row </td></tr>
    <tr><td class="paramname">keyStringCol</td><td>Key string for the column entries </td></tr>
    <tr><td class="paramname">returnValues</td><td>Return Matrix. </td></tr>
    <tr><td class="paramname">convert</td><td>If this is true, and if the node has a units attribute, then conversion to SI units is carried out. Default is true. </td></tr>
    <tr><td class="paramname">matrixSymmetric</td><td>If true entries are made so that the matrix is always symmetric. Default is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l01079">1079</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="stringUtils_8cpp_source.html#l00478">Cantera::atofCheck()</a>, <a class="el" href="ctml_8cpp_source.html#l01180">getStringArray()</a>, <a class="el" href="Array_8h_source.html#l00322">Array2D::nColumns()</a>, <a class="el" href="ct__defs_8h_source.html#l00184">Cantera::npos</a>, <a class="el" href="Array_8h_source.html#l00317">Array2D::nRows()</a>, and <a class="el" href="global_8cpp_source.html#l00182">Cantera::toSI()</a>.</p>

<p>Referenced by <a class="el" href="DebyeHuckel_8cpp_source.html#l00957">DebyeHuckel::initThermoXML()</a>.</p>

</div>
</div>
<a class="anchor" id="a3895954f7c3fcce68146f9ddfff79164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getStringArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCantera_1_1XML__Node.html">Cantera::XML_Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function interprets the value portion of an XML element as a string. </p>
<p>It then separates the string up into tokens according to the location of white space.</p>
<p>The separate tokens are returned in the string vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to get the value from </td></tr>
    <tr><td class="paramname">v</td><td>Output vector containing the string tokens </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ctml_8cpp_source.html#l01180">1180</a> of file <a class="el" href="ctml_8cpp_source.html">ctml.cpp</a>.</p>

<p>References <a class="el" href="stringUtils_8cpp_source.html#l00620">Cantera::tokenizeString()</a>, and <a class="el" href="xml_8cpp_source.html#l00643">XML_Node::value()</a>.</p>

<p>Referenced by <a class="el" href="Elements_8cpp_source.html#l00523">Elements::addElementsFromXML()</a>, <a class="el" href="Phase_8cpp_source.html#l00751">Phase::addElementsFromXML()</a>, <a class="el" href="HMWSoln__input_8cpp_source.html#l01121">HMWSoln::constructPhaseXML()</a>, <a class="el" href="ThermoFactory_8cpp_source.html#l00306">Cantera::formSpeciesXMLNodeList()</a>, <a class="el" href="importKinetics_8cpp_source.html#l00429">Cantera::getFalloff()</a>, <a class="el" href="ctml_8cpp_source.html#l00970">getMap()</a>, <a class="el" href="ctml_8cpp_source.html#l01079">getMatrixValues()</a>, <a class="el" href="ctml_8cpp_source.html#l01020">getPairs()</a>, <a class="el" href="importKinetics_8cpp_source.html#l01045">Cantera::importKinetics()</a>, <a class="el" href="IdealMolalSoln_8cpp_source.html#l00845">IdealMolalSoln::initThermoXML()</a>, <a class="el" href="DebyeHuckel_8cpp_source.html#l00957">DebyeHuckel::initThermoXML()</a>, and <a class="el" href="HMWSoln__input_8cpp_source.html#l01269">HMWSoln::initThermoXML()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="adf11e90282d5d60b62491ed1413d2846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string CTML_Version = &quot;1.4.1&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const Specifying the CTML version number </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Codify what the CTML_Version number means. </dd></dl>

<p>Definition at line <a class="el" href="ctml_8h_source.html#l00029">29</a> of file <a class="el" href="ctml_8h_source.html">ctml.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
